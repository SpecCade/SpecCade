//! Basic oscillator waveform generators.
//!
//! This module provides fundamental waveform generators used by synthesis types.
//! All oscillators are deterministic and produce sample-accurate output.

use std::f64::consts::PI;

use rand::Rng;
use rand_pcg::Pcg32;

/// Two times PI, commonly used in oscillator calculations.
pub const TWO_PI: f64 = 2.0 * PI;

/// Generates a sine wave sample at the given phase.
///
/// # Arguments
/// * `phase` - Phase in radians (0 to 2*PI)
///
/// # Returns
/// Sample value in range [-1.0, 1.0]
#[inline]
pub fn sine(phase: f64) -> f64 {
    phase.sin()
}

/// Generates a square wave sample at the given phase with specified duty cycle.
///
/// # Arguments
/// * `phase` - Phase in radians (0 to 2*PI)
/// * `duty` - Duty cycle (0.0 to 1.0, where 0.5 is a standard square wave)
///
/// # Returns
/// Sample value: 1.0 or -1.0
#[inline]
pub fn square(phase: f64, duty: f64) -> f64 {
    let normalized = phase / TWO_PI;
    if normalized.fract() < duty {
        1.0
    } else {
        -1.0
    }
}

/// Generates a sawtooth wave sample at the given phase.
///
/// Produces a wave that ramps from -1.0 to 1.0 over each cycle.
///
/// # Arguments
/// * `phase` - Phase in radians (0 to 2*PI)
///
/// # Returns
/// Sample value in range [-1.0, 1.0]
#[inline]
pub fn sawtooth(phase: f64) -> f64 {
    let normalized = phase / TWO_PI;
    2.0 * normalized.fract() - 1.0
}

/// Generates a triangle wave sample at the given phase.
///
/// # Arguments
/// * `phase` - Phase in radians (0 to 2*PI)
///
/// # Returns
/// Sample value in range [-1.0, 1.0]
#[inline]
pub fn triangle(phase: f64) -> f64 {
    let normalized = phase / TWO_PI;
    let t = normalized.fract();
    if t < 0.5 {
        4.0 * t - 1.0
    } else {
        3.0 - 4.0 * t
    }
}

/// Generates white noise samples.
///
/// White noise has equal energy at all frequencies.
///
/// # Arguments
/// * `rng` - A deterministic RNG
/// * `num_samples` - Number of samples to generate
///
/// # Returns
/// Vector of samples in range [-1.0, 1.0]
pub fn white_noise(rng: &mut Pcg32, num_samples: usize) -> Vec<f64> {
    (0..num_samples)
        .map(|_| rng.gen::<f64>() * 2.0 - 1.0)
        .collect()
}

/// Generates pink noise samples (1/f spectrum).
///
/// Pink noise has equal energy per octave, resulting in a -3dB/octave slope.
/// Uses the Voss-McCartney algorithm for efficient generation.
///
/// # Arguments
/// * `rng` - A deterministic RNG
/// * `num_samples` - Number of samples to generate
///
/// # Returns
/// Vector of samples (may exceed [-1.0, 1.0], should be normalized)
pub fn pink_noise(rng: &mut Pcg32, num_samples: usize) -> Vec<f64> {
    // Voss-McCartney algorithm with 16 generators
    const NUM_GENERATORS: usize = 16;
    let mut generators: [f64; NUM_GENERATORS] = [0.0; NUM_GENERATORS];

    // Initialize generators with random values
    for gen in generators.iter_mut() {
        *gen = rng.gen::<f64>() * 2.0 - 1.0;
    }

    let mut output = Vec::with_capacity(num_samples);
    let scale = 1.0 / (NUM_GENERATORS as f64).sqrt();

    for i in 0..num_samples {
        // Determine which generators to update based on trailing zeros
        let update_mask = if i == 0 {
            (1 << NUM_GENERATORS) - 1 // Update all on first sample
        } else {
            // Number of trailing zeros determines which generator to update
            let trailing = (i as u32).trailing_zeros() as usize;
            if trailing < NUM_GENERATORS {
                1 << trailing
            } else {
                0
            }
        };

        // Update selected generators
        for (j, gen) in generators.iter_mut().enumerate() {
            if (update_mask & (1 << j)) != 0 {
                *gen = rng.gen::<f64>() * 2.0 - 1.0;
            }
        }

        // Sum all generators
        let sample: f64 = generators.iter().sum();
        output.push(sample * scale);
    }

    output
}

/// Generates brown noise samples (1/f^2 spectrum, Brownian motion).
///
/// Brown noise has a -6dB/octave slope, creating a "rumbling" sound.
/// Generated by integrating white noise.
///
/// # Arguments
/// * `rng` - A deterministic RNG
/// * `num_samples` - Number of samples to generate
///
/// # Returns
/// Vector of samples (may exceed [-1.0, 1.0], should be normalized)
pub fn brown_noise(rng: &mut Pcg32, num_samples: usize) -> Vec<f64> {
    let mut output = Vec::with_capacity(num_samples);
    let mut last = 0.0;

    // Integration coefficient - smaller values produce darker sound
    let leak = 0.02;

    for _ in 0..num_samples {
        let white = rng.gen::<f64>() * 2.0 - 1.0;
        // Leaky integrator to prevent DC drift
        last = last * (1.0 - leak) + white * leak * 10.0;
        output.push(last);
    }

    output
}

/// Phase accumulator for tracking oscillator state.
#[derive(Debug, Clone)]
pub struct PhaseAccumulator {
    phase: f64,
    sample_rate: f64,
}

impl PhaseAccumulator {
    /// Creates a new phase accumulator.
    ///
    /// # Arguments
    /// * `sample_rate` - The audio sample rate in Hz
    pub fn new(sample_rate: f64) -> Self {
        Self {
            phase: 0.0,
            sample_rate,
        }
    }

    /// Advances the phase by the frequency amount and returns the current phase.
    ///
    /// # Arguments
    /// * `frequency` - The oscillator frequency in Hz
    ///
    /// # Returns
    /// The phase in radians (0 to 2*PI)
    #[inline]
    pub fn advance(&mut self, frequency: f64) -> f64 {
        let current = self.phase;
        self.phase += TWO_PI * frequency / self.sample_rate;

        // Wrap phase to prevent floating point precision issues
        if self.phase >= TWO_PI {
            self.phase -= TWO_PI;
        }

        current
    }

    /// Resets the phase to zero.
    pub fn reset(&mut self) {
        self.phase = 0.0;
    }

    /// Sets the current phase in radians.
    ///
    /// The phase is wrapped into `[0, 2Ï€)`.
    pub fn set_phase_radians(&mut self, phase_radians: f64) {
        self.phase = phase_radians.rem_euclid(TWO_PI);
    }

    /// Gets the current phase without advancing.
    pub fn current(&self) -> f64 {
        self.phase
    }
}

/// Band-limited sawtooth using PolyBLEP for anti-aliasing.
///
/// # Arguments
/// * `phase` - Normalized phase (0 to 1)
/// * `dt` - Phase increment per sample (frequency / sample_rate)
///
/// # Returns
/// Sample value in range approximately [-1.0, 1.0]
#[inline]
pub fn polyblep_saw(phase: f64, dt: f64) -> f64 {
    let mut t = phase;
    let mut sample = 2.0 * t - 1.0;

    // Apply PolyBLEP at discontinuity
    if t < dt {
        t /= dt;
        sample -= t + t - t * t - 1.0;
    } else if t > 1.0 - dt {
        t = (t - 1.0) / dt;
        sample -= t * t + t + t + 1.0;
    }

    sample
}

/// Band-limited square wave using PolyBLEP for anti-aliasing.
///
/// # Arguments
/// * `phase` - Normalized phase (0 to 1)
/// * `dt` - Phase increment per sample (frequency / sample_rate)
/// * `duty` - Duty cycle (0.0 to 1.0)
///
/// # Returns
/// Sample value in range approximately [-1.0, 1.0]
#[inline]
pub fn polyblep_square(phase: f64, dt: f64, duty: f64) -> f64 {
    let mut sample = if phase < duty { 1.0 } else { -1.0 };

    // Apply PolyBLEP at rising edge
    if phase < dt {
        let t = phase / dt;
        sample += poly_blep(t);
    } else if phase > 1.0 - dt {
        let t = (phase - 1.0) / dt;
        sample += poly_blep(t);
    }

    // Apply PolyBLEP at falling edge
    if phase > duty - dt && phase < duty + dt {
        let t = (phase - duty) / dt;
        sample -= poly_blep(t);
    }

    sample
}

/// PolyBLEP correction function.
#[inline]
fn poly_blep(t: f64) -> f64 {
    if t > 0.0 {
        // After discontinuity
        -t * t - 2.0 * t - 1.0
    } else {
        // Before discontinuity
        t * t + 2.0 * t + 1.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::rng::create_rng;

    #[test]
    fn test_sine_range() {
        for i in 0..100 {
            let phase = (i as f64 / 100.0) * TWO_PI;
            let sample = sine(phase);
            assert!((-1.0..=1.0).contains(&sample));
        }
    }

    #[test]
    fn test_sine_zero_crossings() {
        assert!((sine(0.0)).abs() < 1e-10);
        assert!((sine(PI)).abs() < 1e-10);
    }

    #[test]
    fn test_square_wave() {
        // 50% duty cycle
        assert_eq!(square(0.0, 0.5), 1.0);
        assert_eq!(square(PI * 0.9, 0.5), 1.0);
        assert_eq!(square(PI * 1.1, 0.5), -1.0);

        // 25% duty cycle
        assert_eq!(square(0.0, 0.25), 1.0);
        assert_eq!(square(PI * 0.4, 0.25), 1.0);
        assert_eq!(square(PI * 0.6, 0.25), -1.0);
    }

    #[test]
    fn test_sawtooth_range() {
        for i in 0..100 {
            let phase = (i as f64 / 100.0) * TWO_PI;
            let sample = sawtooth(phase);
            assert!((-1.0..=1.0).contains(&sample));
        }
    }

    #[test]
    fn test_triangle_range() {
        for i in 0..100 {
            let phase = (i as f64 / 100.0) * TWO_PI;
            let sample = triangle(phase);
            assert!((-1.0..=1.0).contains(&sample));
        }
    }

    #[test]
    fn test_white_noise_determinism() {
        let mut rng1 = create_rng(42);
        let mut rng2 = create_rng(42);

        let noise1 = white_noise(&mut rng1, 100);
        let noise2 = white_noise(&mut rng2, 100);

        assert_eq!(noise1, noise2);
    }

    #[test]
    fn test_pink_noise_determinism() {
        let mut rng1 = create_rng(42);
        let mut rng2 = create_rng(42);

        let noise1 = pink_noise(&mut rng1, 100);
        let noise2 = pink_noise(&mut rng2, 100);

        assert_eq!(noise1, noise2);
    }

    #[test]
    fn test_brown_noise_determinism() {
        let mut rng1 = create_rng(42);
        let mut rng2 = create_rng(42);

        let noise1 = brown_noise(&mut rng1, 100);
        let noise2 = brown_noise(&mut rng2, 100);

        assert_eq!(noise1, noise2);
    }

    #[test]
    fn test_phase_accumulator() {
        let mut acc = PhaseAccumulator::new(44100.0);

        // At 440 Hz, we should complete a full cycle in 44100/440 = ~100 samples
        for _ in 0..100 {
            acc.advance(440.0);
        }

        // Phase should have wrapped around approximately once
        assert!(acc.current() < TWO_PI);
    }
}
